
import { UserRole, User, ScheduleItem, VideoContent, AppConfig } from '../types';
import { driveService } from './googleDrive';

// 1. Google Apps Script Web App URL (from .env)
const SCRIPT_URL: string = import.meta.env.VITE_SCRIPT_URL;

// 2. Google Client ID (from .env)
const GOOGLE_CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID || '207152218307-5bab17pik3kiosq3jvdo8fiilp373bmn.apps.googleusercontent.com';

export const googleAuthService = {
  signIn: async (role: UserRole): Promise<User> => {
    // ---------------------------------------------------------
    // MOCK LOGIN FOR TESTING (Toggle this block for testing/production)
    // ---------------------------------------------------------
    /*
    return new Promise((resolve) => {
      setTimeout(() => {
        if (role === 'monk') {
          resolve({
            name: 'ì •ìˆ˜ìŠ¤ë‹˜',
            email: 'monk@jeongsu.org',
            photoUrl: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Monk',
            streak: 108,
            role: 'monk',
            trackingIds: [],
            dharmaName: 'ì •ìˆ˜'
          });
        } else {
          resolve({
            name: 'ê¹€ë³´ì‚´',
            email: 'bosal@example.com',
            photoUrl: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Felix',
            streak: 12,
            role: 'believer',
            trackingIds: ['1', '2', '3', '7'] // Mock saved IDs
          });
        }
      }, 500);
    });
    */
    // ---------------------------------------------------------

    return new Promise((resolve, reject) => {
      if (!window.google) return reject("Google SDK not loaded");

      // Drive APIëŠ” ìŠ¤ë‹˜ë§Œ í•„ìš” (ìŠ¤ë‹˜ ê³„ì • í•˜ë‚˜ì˜ ë“œë¼ì´ë¸Œë§Œ ì—°ë™)
      const scopes = role === 'monk'
        ? 'email profile openid https://www.googleapis.com/auth/drive.readonly'
        : 'email profile openid';

      const client = window.google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CLIENT_ID,
        scope: scopes,
        callback: async (tokenResponse: any) => {
          if (tokenResponse && tokenResponse.access_token) {
            try {
              // Save access token for Drive API (ìŠ¤ë‹˜ë§Œ)
              if (role === 'monk') {
                driveService.setAccessToken(tokenResponse.access_token);
                console.log('âœ… Drive API access token saved (monk only)');
              }

              // 1. Get Google Profile
              const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                headers: { Authorization: `Bearer ${tokenResponse.access_token}` },
              });
              const userInfo = await userInfoResponse.json();

              const tempUser: User = {
                name: userInfo.name,
                email: userInfo.email,
                photoUrl: userInfo.picture,
                streak: 1,
                role: role,
                trackingIds: []
              };

              // 2. SYNC with DB immediately to get persistent data (trackingIds)
              const syncedUser = await dbService.syncUser(tempUser);
              resolve(syncedUser);

            } catch (e) {
              reject(e);
            }
          } else {
            reject("No access token");
          }
        },
        error_callback: (error: any) => {
           if (error.type === 'popup_closed') {
             // Ignore popup closed
           } else {
             reject(new Error(`Google Login Error: ${error.type}. Check console for details.`));
             // Tip for redirect_uri_mismatch
             if(error.type === 'invalid_request' || error.type === 'redirect_uri_mismatch') {
               alert(`êµ¬ê¸€ ë¡œê·¸ì¸ ì„¤ì • ì˜¤ë¥˜ì…ë‹ˆë‹¤.\nGoogle Cloud Consoleì— ì•„ë˜ ì£¼ì†Œë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”:\n${window.location.origin}`);
             }
           }
        }
      });

      client.requestAccessToken();
    });
  },

  signOut: async () => {
    if (window.google?.accounts?.id) {
      window.google.accounts.id.disableAutoSelect();
    }
  }
};

// --- DB Service ---

// ë¡œì»¬ ëª¨ë“œ í”Œë˜ê·¸ (Google Apps Script ì—†ì´ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ë§Œ ì‚¬ìš©)
const USE_LOCAL_MODE = false; // âœ… Google Sheetsì— ì €ì¥ í™œì„±í™”

const callScript = async (action: string, payload: any = {}) => {
  console.log(`ğŸ“¡ API ìš”ì²­: ${action}`, payload);

  // ë¡œì»¬ ëª¨ë“œ: ì„œë²„ ì—†ì´ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ë§Œ ì‚¬ìš©
  if (USE_LOCAL_MODE) {
    console.log('ğŸ’¾ ë¡œì»¬ ëª¨ë“œ: ì„œë²„ ëŒ€ì‹  ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ì‚¬ìš©');
    return { status: 'success', message: 'Local mode - data saved to localStorage' };
  }

  // ì„œë²„ ëª¨ë“œ - POST ë°©ì‹ ì‚¬ìš©
  try {
    const response = await fetch(SCRIPT_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        action,
        ...payload
      }),
      redirect: 'follow'
    });

    console.log(`ğŸ“¡ ì‘ë‹µ ìƒíƒœ: ${response.status} ${response.statusText}`);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const json = await response.json();
    console.log(`ğŸ“¡ ì‘ë‹µ ë°ì´í„°:`, json);

    if (json.status === 'error') {
       throw new Error(json.message || 'API returned error status');
    }

    return json;

  } catch (error) {
    console.error(`âŒ API Call ${action} failed:`, error);
    console.error('ìš”ì²­ URL:', SCRIPT_URL);
    console.error('ìš”ì²­ í˜ì´ë¡œë“œ:', { action, ...payload });
    throw error;
  }
};

export const dbService = {
  getSettings: async (): Promise<AppConfig> => {
    try {
      const res = await callScript('GET_SETTINGS');
      if (res.settings) {
        localStorage.setItem('appConfig', JSON.stringify(res.settings));
        return res.settings;
      }
    } catch (e) {
      // Silently use cache if API fails
    }
    const cache = localStorage.getItem('appConfig');
    return cache ? JSON.parse(cache) : {};
  },
  
  updateSettings: async (settings: AppConfig) => {
    const res = await callScript('UPDATE_SETTINGS', { settings });
    localStorage.setItem('appConfig', JSON.stringify(settings));
    return res;
  },

  getVideos: async (): Promise<VideoContent[]> => {
    try {
      const res = await callScript('GET_VIDEOS');
      if(res.videos) {
        localStorage.setItem('videos', JSON.stringify(res.videos));
        return res.videos;
      }
    } catch (e) {
      // Silently use cache if API fails
    }
    const cache = localStorage.getItem('videos');
    return cache ? JSON.parse(cache) : [];
  },

  addVideo: async (video: Partial<VideoContent>) => {
    return await callScript('ADD_VIDEO', { video });
  },

  updateVideoStatus: async (id: string, status: 'draft' | 'published') => {
    const updates: any = { status };
    if (status === 'published') {
      updates.publishedAt = new Date().toISOString();
    }
    return await callScript('UPDATE_VIDEO', { id, updates });
  },
  
  deleteVideo: async (id: string) => {
    return await callScript('DELETE_VIDEO', { id });
  },

  getSchedules: async (email: string, useCache: boolean = true): Promise<ScheduleItem[]> => {
    // ğŸš€ ìºì‹œ ìš°ì„  ì‚¬ìš© (ë¹ ë¥¸ ì´ˆê¸° ë¡œë”©)
    if (useCache) {
      const cache = localStorage.getItem(`schedules_${email}`);
      if (cache) {
        console.log('ğŸ’¾ ìºì‹œì—ì„œ ì¼ì • ë¡œë“œ (ë¹ ë¥¸ í‘œì‹œ)');

        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì„œë²„ ë°ì´í„° ì—…ë°ì´íŠ¸ (ë‹¤ìŒë²ˆ ë¡œë”©ì„ ìœ„í•´)
        setTimeout(() => {
          dbService.getSchedules(email, false).catch(e =>
            console.warn('ë°±ê·¸ë¼ìš´ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', e)
          );
        }, 100);

        return JSON.parse(cache);
      }
    }

    // ì„œë²„ì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    try {
      const res = await callScript('GET_SCHEDULES');
      const all = res.schedules || [];
      console.log('ğŸ“… ì„œë²„ì—ì„œ ì¼ì • ë¡œë“œ:', all.length, 'ê°œ');

      // Get all users to check who is a monk
      const usersRes = await callScript('GET_USERS');
      const monks = (usersRes.users || []).filter((u: any) => u.role === 'monk').map((u: any) => u.email);

      // Include schedules that are:
      // 1. Temple events (everyone can see)
      // 2. Owned by this user
      // 3. User is invited to this schedule
      // 4. Owned by a monk (all monk schedules visible to everyone)
      const filtered = all.filter((s: ScheduleItem) =>
        s.type === 'temple' ||
        s.ownerEmail === email ||
        (s.invitedEmails && s.invitedEmails.includes(email)) ||
        (s.ownerEmail && monks.includes(s.ownerEmail))
      );

      console.log('âœ… í•„í„°ë§ëœ ì¼ì •:', filtered.length, 'ê°œ');

      // ìºì‹œ ì—…ë°ì´íŠ¸
      localStorage.setItem(`schedules_${email}`, JSON.stringify(filtered));
      return filtered;
    } catch (e) {
      console.warn('ì¼ì • ë¡œë“œ ì‹¤íŒ¨, ìºì‹œ ì‚¬ìš©:', e);
      const cache = localStorage.getItem(`schedules_${email}`);
      return cache ? JSON.parse(cache) : [];
    }
  },

  addSchedule: async (schedule: Partial<ScheduleItem>, email: string) => {
    return await callScript('ADD_SCHEDULE', { schedule: { ...schedule, ownerEmail: email } });
  },

  updateSchedule: async (schedule: Partial<ScheduleItem>) => {
    return await callScript('UPDATE_SCHEDULE', { schedule });
  },

  deleteSchedule: async (id: string) => {
    return await callScript('DELETE_SCHEDULE', { id });
  },

  rsvpEvent: async (scheduleId: string, userEmail: string, isJoining: boolean) => {
    return await callScript('RSVP_EVENT', { scheduleId, userEmail, isJoining });
  },

  updateUserGoals: async (email: string, trackingIds: string[]) => {
    console.log('ğŸ”„ UPDATE_GOALS í˜¸ì¶œ:', { email, trackingIds });
    const result = await callScript('UPDATE_GOALS', { email, trackingIds });
    console.log('ğŸ“¥ UPDATE_GOALS ì‘ë‹µ:', result);
    return result;
  },
  
  syncUser: async (user: User) => {
    try {
      const res = await callScript('LOGIN', { user });
      if (res && res.user) {
        console.log('âœ… ì‚¬ìš©ì ì„œë²„ ë™ê¸°í™” ì„±ê³µ:', res.user);
        return res.user;
      }
    } catch (e) {
      console.warn('âš ï¸ ì„œë²„ ë™ê¸°í™” ì‹¤íŒ¨, ë¡œì»¬ ë°ì´í„° ì‚¬ìš©:', e);
    }
    // Fallback: ì„œë²„ ë™ê¸°í™” ì‹¤íŒ¨ ì‹œ ì›ë³¸ user ë°˜í™˜
    console.log('ğŸ’¾ ë¡œì»¬ ì‚¬ìš©ì ë°ì´í„° ì‚¬ìš©:', user);
    return user;
  },

  updateUserProfile: async (email: string, updates: any) => {
    return await callScript('UPDATE_PROFILE', { email, updates });
  },

  updateNotificationSettings: async (email: string, settings: any) => {
    return await callScript('UPDATE_NOTIFICATIONS', { email, settings });
  },
  
  getPracticeLogs: async (email: string) => {
    try {
      const res = await callScript('GET_PRACTICE_LOGS', { email });
      if(res.logs) {
        localStorage.setItem(`logs_${email}`, JSON.stringify(res.logs));
        return res.logs;
      }
    } catch (e) {
       console.warn("Failed to fetch logs, using cache", e);
    }
    const cache = localStorage.getItem(`logs_${email}`);
    return cache ? JSON.parse(cache) : [];
  },
  
  savePracticeLog: async (log: any) => {
    console.log('ğŸ“¡ API í˜¸ì¶œ: SAVE_PRACTICE', log);
    try {
      const result = await callScript('SAVE_PRACTICE', { log });
      console.log('âœ… Google Sheets ì €ì¥ ì„±ê³µ:', result);

      // ë¡œì»¬ ìºì‹œì—ë„ ì €ì¥
      const cacheKey = `logs_${log.email}`;
      const cached = localStorage.getItem(cacheKey);
      const logs = cached ? JSON.parse(cached) : [];
      const updated = logs.filter((l: any) => l.id !== log.id);
      updated.push(log);
      localStorage.setItem(cacheKey, JSON.stringify(updated));
      console.log('ğŸ’¾ ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸ ì™„ë£Œ');

      return result;
    } catch (error) {
      console.error('âŒ Google Sheets ì €ì¥ ì‹¤íŒ¨:', error);
      console.error('Apps Scriptê°€ ë°°í¬ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”!');
      throw error;
    }
  },

  getUsers: async () => {
    try {
      const res = await callScript('GET_USERS');
      if (res.users) {
        localStorage.setItem('users', JSON.stringify(res.users));
        return res.users;
      }
    } catch (e) {
      console.warn('ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', e);
    }
    const cache = localStorage.getItem('users');
    return cache ? JSON.parse(cache) : [];
  },

  // ğŸ†• ìˆ˜í–‰ í•­ëª© ê´€ë¦¬
  getPracticeItems: async () => {
    try {
      const res = await callScript('GET_PRACTICE_ITEMS');
      if (res.items) {
        localStorage.setItem('practiceItems', JSON.stringify(res.items));
        return res.items;
      }
    } catch (e) {
      console.warn('ìˆ˜í–‰ í•­ëª© ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©:', e);
    }

    // ìºì‹œ í™•ì¸
    const cache = localStorage.getItem('practiceItems');
    if (cache) return JSON.parse(cache);

    // ğŸ“¦ Fallback: ê¸°ë³¸ í•­ëª© (í•„ìˆ˜ 2ê°œ + ì„ íƒ 23ê°œ = ì´ 25ê°œ)
    return [
      // í•„ìˆ˜ í•­ëª©
      { id: '1', category: 'í•„ìˆ˜', question: 'ê²½ì „ì½ê¸°', order: 1 },
      { id: '2', category: 'í•„ìˆ˜', question: 'ì—¼ë¶ˆ/ì°¸ì„ ', order: 2 },
      // ì •ê²¬Â·ê³µê´€
      { id: '3', category: 'ì •ê²¬Â·ê³µê´€', question: 'ë‚˜/ì‚¬ë¬¼ì— ëŒ€í•œ ì§‘ì°©ì„ ìê°í–ˆëŠ”ê°€?', order: 3 },
      { id: '4', category: 'ì •ê²¬Â·ê³µê´€', question: 'ëª¨ë“ ê²ƒì´ ì¸ì—°ë”°ë¼ ì´ë£¨ì–´ ì§ì„ ë– ì˜¬ë ¸ëŠ”ê°€?', order: 4 },
      { id: '5', category: 'ì •ê²¬Â·ê³µê´€', question: 'ê³µì„ í—ˆë¬´ê°€ ì•„ë‹Œ ê´€ê³„ë¡œ ì²´í—˜í–ˆëŠ”ê°€?', order: 5 },
      // ë³´ë¦¬ì‹¬
      { id: '6', category: 'ë³´ë¦¬ì‹¬', question: 'í•˜ë£¨ ì‹œì‘ í•˜ê¸° ì „ ë°œì›ì„ í–ˆëŠ”ê°€?', order: 6 },
      { id: '7', category: 'ë³´ë¦¬ì‹¬', question: 'í˜ë“¤ ë•Œë„ ë°œì›ì„ ìƒê¸°í–ˆëŠ”ê°€?', order: 7 },
      { id: '8', category: 'ë³´ë¦¬ì‹¬', question: 'ì„±ê³¼ë¥¼ ë‚´ ê²ƒì´ë¼ ì§‘ì°©í•˜ì§€ ì•Šì•˜ëŠ”ê°€?', order: 8 },
      // ìœ¡ë°”ë¼ë°€
      { id: '9', category: 'ë³´ì‹œ', question: 'ì¬ë¬¼Â·ë§Â·ì§€í˜œì˜ ë³´ì‹œë¥¼ ì‹¤ì²œí–ˆëŠ”ê°€?', order: 9 },
      { id: '10', category: 'ì§€ê³„', question: 'íƒ€ì¸ì—ê²Œ í•´ë¥¼ ë¼ì¹˜ì§€ ì•Šì•˜ëŠ”ê°€?', order: 10 },
      { id: '11', category: 'ì¸ìš•', question: 'ë¶„ë…¸ ëŒ€ì‹  ì•Œì•„ì°¨ë¦¼ì„ ìœ ì§€í–ˆëŠ”ê°€?', order: 11 },
      { id: '12', category: 'ì •ì§„', question: 'ìˆ˜í–‰Â·í•™ìŠµÂ·ë´‰ì‚¬ë¥¼ ê²Œì„ë¦¬í•˜ì§€ ì•Šì•˜ëŠ”ê°€?', order: 12 },
      { id: '13', category: 'ì„ ì •', question: 'ì¢Œì„ Â·í˜¸í¡ê´€ì„ ì‹¤ì²œí–ˆëŠ”ê°€?', order: 13 },
      { id: '14', category: 'ë°˜ì•¼', question: 'ë°”ë¼ë°€ì„ ê³µê´€ê³¼ ì—°ê²°í–ˆëŠ”ê°€?', order: 14 },
      // ë°©í¸Â·ìë¹„
      { id: '15', category: 'ë°©í¸Â·ìë¹„', question: 'ìƒëŒ€ì˜ ìƒí™©ì— ë§ì¶° ë§í–ˆëŠ”ê°€?', order: 15 },
      { id: '16', category: 'ë°©í¸Â·ìë¹„', question: 'ì˜³ê³  ê·¸ë¦„ë³´ë‹¤ ì´ìµì„ ìš°ì„ í–ˆëŠ”ê°€?', order: 16 },
      { id: '17', category: 'ë°©í¸Â·ìë¹„', question: 'í–‰ìœ„ í›„ ì§‘ì°©ì´ ë‚¨ì§€ ì•Šì•˜ëŠ”ê°€?', order: 17 },
      // ë‘ ì§„ë¦¬
      { id: '18', category: 'ë‘ ì§„ë¦¬', question: 'ì„¸ì†ì œì—ì„œ ë„ë•Â·ê·œë²”ì„ ì§€ì¼°ëŠ”ê°€?', order: 18 },
      { id: '19', category: 'ë‘ ì§„ë¦¬', question: 'ìŠ¹ì˜ì œì—ì„œ ë¬´ìì„±ì„ ê¸°ì–µí–ˆëŠ”ê°€?', order: 19 },
      { id: '20', category: 'ë‘ ì§„ë¦¬', question: 'ë‘ ì§„ë¦¬ë¥¼ ê· í˜• ìˆê²Œ ì ìš©í–ˆëŠ”ê°€?', order: 20 },
      // ë¬´ì£¼ì—´ë°˜
      { id: '21', category: 'ë¬´ì£¼ì—´ë°˜', question: 'ì—´ë°˜ì— ì§‘ì°©í•˜ì§€ ì•Šì•˜ëŠ”ê°€?', order: 21 },
      { id: '22', category: 'ë¬´ì£¼ì—´ë°˜', question: 'ë“ì‹¤ì— ë§¤ì´ì§€ ì•Šì•˜ëŠ”ê°€?', order: 22 },
      { id: '23', category: 'ë¬´ì£¼ì—´ë°˜', question: 'ë¨¸ë¬¼ ê³³ ì—†ìŒì˜ íƒœë„ë¥¼ ì ìš©í–ˆëŠ”ê°€?', order: 23 },
      // ìê¸° ì„±ì°°
      { id: '24', category: 'ìê¸° ì„±ì°°', question: 'ì§‘ì°© íŒ¨í„´ì„ ê¸°ë¡í–ˆëŠ”ê°€?', order: 24 },
      { id: '25', category: 'ìê¸° ì„±ì°°', question: 'ë§ˆìŒë¹„ì›€ê³¼ ìë¹„ê°€ ì„œë¡œë¥¼ ë³´ì™„í–ˆëŠ”ê°€?', order: 25 }
    ];
  }
};
